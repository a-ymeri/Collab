[{"C:\\Users\\PC\\Desktop\\Thesis\\ThesisSystem\\Collab\\frontend\\collab-editor-ts\\src\\App.tsx":"1","C:\\Users\\PC\\Desktop\\Thesis\\ThesisSystem\\Collab\\frontend\\collab-editor-ts\\src\\reportWebVitals.ts":"2","C:\\Users\\PC\\Desktop\\Thesis\\ThesisSystem\\Collab\\frontend\\collab-editor-ts\\src\\index.tsx":"3","C:\\Users\\PC\\Desktop\\Thesis\\ThesisSystem\\Collab\\frontend\\collab-editor-ts\\src\\SyncingEditor.tsx":"4"},{"size":1146,"mtime":1611852603739,"results":"5","hashOfConfig":"6"},{"size":425,"mtime":1610121128405,"results":"7","hashOfConfig":"6"},{"size":500,"mtime":1610188152135,"results":"8","hashOfConfig":"6"},{"size":20960,"mtime":1612289039774,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1pgjlgp",{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"16","messages":"17","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"18"},"C:\\Users\\PC\\Desktop\\Thesis\\ThesisSystem\\Collab\\frontend\\collab-editor-ts\\src\\App.tsx",[],"C:\\Users\\PC\\Desktop\\Thesis\\ThesisSystem\\Collab\\frontend\\collab-editor-ts\\src\\reportWebVitals.ts",[],"C:\\Users\\PC\\Desktop\\Thesis\\ThesisSystem\\Collab\\frontend\\collab-editor-ts\\src\\index.tsx",[],"C:\\Users\\PC\\Desktop\\Thesis\\ThesisSystem\\Collab\\frontend\\collab-editor-ts\\src\\SyncingEditor.tsx",["19","20"],"import React, { useEffect, useMemo, useRef, useState } from 'react'\r\nimport { createEditor, InsertTextOperation, Operation } from 'slate'\r\nimport { Slate, Editable, withReact } from 'slate-react'\r\n\r\nimport * as Stomp from \"stompjs\";\r\nimport SockJS from \"sockjs-client\";\r\nimport { RemoveTextOperation } from 'slate';\r\ninterface Props { }\r\n\r\n\r\ninterface OperationKey {\r\n    siteID: number,\r\n    stateID: number\r\n}\r\n\r\ntype Identifier = {\r\n    siteID: number,\r\n    stateID: number\r\n}\r\n\r\ntype CustomOperation = (InsertTextOperation | RemoveTextOperation) & Identifier;\r\n\r\nconst socket = new SockJS('http://127.0.0.1:8080/collab-editor');\r\nconst stompClient = Stomp.over(socket);\r\nlet stateID: number = 0.0;\r\n//TODO: get ID from the back, also UUID\r\nconst ID = Date.now();\r\nconsole.log(ID);\r\n\r\nlet effectsRelation = new Map<OperationKey, OperationKey>();\r\n\r\nlet historyBuffer: CustomOperation[] = []; // List of changes that have been recorded, potentially useful for ETSOS\r\nlet toSendBuffer: CustomOperation[] = []; // List of changes TO BE SENT, constantly altered by changes before ACK\r\nlet concurrentChanges: CustomOperation[] = []; //List of changes to be sent, unaltered by changes before ACK, used for transformation\r\n\r\nlet received: CustomOperation[] = [];\r\nexport const SyncingEditor: React.FC<Props> = () => {\r\n    const editor = useMemo(() => withReact(createEditor()), [])\r\n\r\n    //const [historyBuffer, setHistoryBuffer] = useState([] as CustomOperation[]);\r\n\r\n    const remote = useRef(false);\r\n    const sending = useRef(false);\r\n    // Add the initial value when setting up our state.\r\n    const [value, setValue] = useState([\r\n        {\r\n            type: 'paragraph',\r\n            children: [{ text: '' }],\r\n        },\r\n    ])\r\n\r\n    useEffect(() => {\r\n\r\n        if (!stompClient.connected) {\r\n            stompClient.connect({}, function () {\r\n                stompClient.subscribe('/app/file/1/getDocument', function (data: any) {\r\n                    //console.log(data.body.text);\r\n                    setValue([\r\n                        {\r\n                            type: 'paragraph',\r\n                            children: [{ text: JSON.parse(data.body).text }]\r\n                        },\r\n                    ]);\r\n                    stateID = Number(JSON.parse(data.body).state);\r\n                });\r\n\r\n                stompClient.subscribe('/topic/1', function (data: any) {\r\n                    let op: CustomOperation = JSON.parse(data.body);\r\n                    onReceived(op);\r\n                    received.push(op);\r\n                });\r\n\r\n            })\r\n        }\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [])\r\n\r\n    function onReceived(op: CustomOperation) {\r\n\r\n        if (op.siteID !== ID) {\r\n\r\n            console.log(\"Remote execution of: character:\" + op.text + \" | offset:\" + op.offset + \" | stateID: \" + op.stateID);\r\n            //PUT BACK ON LINE ~107 IF SHIT DOESNT WORK TODO:\r\n            //op = integrate(op, historyBuffer, toSendBuffer); //TODO: change back to concurrent MAYBE\r\n\r\n\r\n            let tempOp: CustomOperation;\r\n\r\n\r\n\r\n            //If it's below 0, useless operation\r\n            if (op.offset >= 0) {\r\n                for (let i = 0; i < toSendBuffer.length; i++) {\r\n                    tempOp = copy(op);\r\n                    op = inclusionTransform(op, toSendBuffer[i]);\r\n                    if (op.offset === -1) {\r\n                        toSendBuffer.splice(i, 1);\r\n                        break;\r\n                    }\r\n                    toSendBuffer[i] = inclusionTransform(toSendBuffer[i], tempOp);\r\n\r\n                }\r\n            }\r\n\r\n            toSendBuffer.forEach((operation, index) => {\r\n                toSendBuffer[index].stateID++;\r\n            })\r\n            \r\n            if (op.offset >= 0) {\r\n                remote.current = true;\r\n\r\n                editor.apply(op);\r\n                historyBuffer.push(op)\r\n                //setHistoryBuffer(hb => [...hb, op]);\r\n                remote.current = false;\r\n                stateID++;\r\n                console.log(\"Remote execution of: character:\" + op.text + \" | offset:\" + op.offset + \" | stateID: \" + op.stateID);\r\n            }\r\n        } else {\r\n            //Ack received\r\n            toSendBuffer.forEach((operation, index) => {\r\n                toSendBuffer[index].stateID++;\r\n            })\r\n            toSendBuffer.splice(0, 1);\r\n            concurrentChanges.splice(0, 1);\r\n            sending.current = false;\r\n            if (toSendBuffer.length > 0) {\r\n                sendCharacter(toSendBuffer[0] as CustomOperation)\r\n            }\r\n            stateID++;\r\n            historyBuffer.push(op);\r\n        }\r\n    }\r\n\r\n    useEffect(() => {\r\n        console.log(value[0].children[0].text);\r\n    }, [value])\r\n\r\n    function sendCharacter(operation: Operation) {\r\n        //stompClient.send(\"/app/sendcharacter\", {}, JSON.stringify({type: operation.type, character: operation.text, index: operation.offset, id: ID, stateID: stateID}));\r\n        if (!sending.current) {\r\n            sending.current = true;\r\n\r\n            setTimeout(() => {\r\n                stompClient.send(\"/app/sendcharacter\", {}, JSON.stringify(operation))\r\n            }, 1500); //was setTimeout\r\n\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <Slate\r\n                editor={editor}\r\n                value={value}\r\n                onChange={newValue => {\r\n                    setValue(newValue as any);\r\n\r\n                    // const ops = newValue.operations.filter()\r\n                    const ops = editor.operations.filter(o => {\r\n                        if (o) { //not undefined\r\n                            return (\r\n                                o.type === \"remove_text\" ||\r\n                                o.type === \"insert_text\"\r\n                            );\r\n                        }\r\n                        return false;\r\n                    })//.map((o) => ({ ...o, data: { id: ID, stateID: stateID } })); // instead of one, get some unique identifier\r\n\r\n                    ops.forEach((op) => {\r\n                        if (!op.siteID) {\r\n                            op.siteID = ID;\r\n                            op.stateID = stateID;\r\n                            toSendBuffer.push(op as CustomOperation);\r\n                            concurrentChanges.push(op as CustomOperation);\r\n                            console.log(\"Local change:\" + value[0].children[0].text)\r\n                            console.log(\"offset: \" + op.offset + \"| character: \" + op.text + \"| stateID: \" + op.stateID)\r\n                            //TODO: uncomment\r\n                            sendCharacter(op);\r\n                        }\r\n\r\n                    });\r\n                }}\r\n            >\r\n                <Editable\r\n                    onKeyDown={event => {\r\n\r\n                    }} />\r\n            </Slate>\r\n            <button onClick={() => {\r\n                if (toSendBuffer.length > 0)\r\n                    sendCharacter(toSendBuffer[0] as CustomOperation)\r\n            }\r\n            }>Send</button>\r\n            <button onClick={() => {\r\n                if (received.length > 0)\r\n                    onReceived(received.splice(0, 1)[0])\r\n            }}>Receive</button>\r\n        </div>\r\n    )\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n    TRANSFORMATION FUNCTIONS\r\n    MAYBE I PUT THESE IN ANOTHER FILE\r\n    MAYBE I DON'T\r\n    WILL SEE\r\n    */\r\n\r\n\r\n    //TODO: Re-evaluate the need for happened, etsoshappened etc.\r\n    function integrate(op: CustomOperation, happened: CustomOperation[], concurrent: CustomOperation[]) {\r\n        // Normally this should be a clear split anyway but it also contextually\r\n        // serializes if needed\r\n        // Will have to rethink the necessity of the serial contextualization but it\r\n        // doesn't hurt the performance much\r\n\r\n\r\n        //for now, gonna comment these, TODO: revisir\r\n        // let transposedLists = transposePreCon(op, sequence);\r\n        // let happened: CustomOperation[] = transposedLists[0];\r\n        // let concurrent: CustomOperation[] = transposedLists[1];\r\n\r\n\r\n        let newOp: CustomOperation;\r\n\r\n        // If no concurrent operations, just return and dont transform\r\n        if (concurrent.length === 0) {\r\n\r\n            newOp = copy(op);\r\n            return newOp;\r\n        }\r\n\r\n        if (op.type === \"remove_text\") {\r\n            newOp = it_sq(op, concurrent);\r\n            return newOp;\r\n        } else { // op.type == \"ins\"\r\n\r\n            // fixed list\r\n            let etsos_happened: CustomOperation[] = buildETSOS(happened);\r\n\r\n            // insertions and deletions that have happened\r\n            let insDelLists = transposeInsDel(etsos_happened);\r\n            // ArrayList<Operation> happenedInsert = insDelLists.get(0);\r\n            let happenedDelete: CustomOperation[] = insDelLists[1];\r\n\r\n            // all deletions that have happened and concurrent operations\r\n            let newList: CustomOperation[] = happenedDelete.concat(concurrent);\r\n            let happenedDelConc: CustomOperation[] = buildETSOS(newList);\r\n\r\n            // All insertions and deletions\r\n            let insDels = transposeInsDel(happenedDelConc);\r\n            let insertions: CustomOperation[] = insDels[0];\r\n            //console.log(insertions.join());\r\n            let deletions: CustomOperation[] = insDels[1];\r\n            //console.log(deletions.join())\r\n\r\n            let innerOp: CustomOperation = et_sq(op, happenedDelete); // o'', this is the back backwards\r\n\r\n            let allInsDels: CustomOperation[] = insertions.concat(deletions);\r\n            newOp = it_sq(innerOp, allInsDels);\r\n            return newOp;\r\n        }\r\n    }\r\n\r\n\r\n    function inclusionTransform(o1: CustomOperation, o2: CustomOperation) {\r\n        /*-1 = O1 is to the left of O2, so don't transform\r\n         * 0 = Same position, used for double deletions\r\n         * 1 = O1 is to the right of O2, transform*/\r\n\r\n        //TODO: Uncomment\r\n        let relationship: number = get_ER_IT(o1, o2);\r\n\r\n        // Clone o1 into newOp1 so we can modify newOp1 without affecting o1\r\n        let newOp1: CustomOperation = copy(o1);\r\n\r\n        if (relationship === 0) { // Same position, double deletion\r\n            newOp1.offset = -1;// position = -1 -> Don't delete, identity operation\r\n        } else {\r\n            if (relationship === 1) { // o2 is to the left of o1\r\n                if (o2.type === \"insert_text\") {// ins = insertion operator\r\n                    newOp1.offset++; // position++\r\n                } else { // o2.type = deletion\r\n                    newOp1.offset--;// position--\r\n                }\r\n            }\r\n        }\r\n        return newOp1;\r\n    }\r\n\r\n    function get_ER_IT(o1: CustomOperation, o2: CustomOperation) {\r\n\r\n        // Check if there is a mapping of o1->o2 or o2->o1\r\n        let o1Key = { siteID: o1.siteID as number, stateID: o1.stateID as number };\r\n        let o2Key = { siteID: o2.siteID as number, stateID: o2.stateID as number };\r\n        if (effectsRelation.get(o1Key) === o2Key) {\r\n            return -1;\r\n        }\r\n        if (effectsRelation.get(o2Key) === o1Key) {\r\n            return 1;\r\n        }\r\n\r\n        let relationship = 1;\r\n\r\n        // If no existing relationship, create a new one\r\n        if (o1.offset < o2.offset) {\r\n            relationship = -1; // I.e. don't transform\r\n            effectsRelation.set(o1Key, o2Key);\r\n        } else if (o1.offset === o2.offset) {\r\n            // If two insertions, arbitrarily choose by site id, don't transform\r\n            if (o1.type === \"insert_text\" && o2.type === \"insert_text\" && o1.siteID < o2.siteID) {\r\n                relationship = -1;\r\n                effectsRelation.set(o1Key, o2Key);\r\n            } else if (o1.type === \"remove_text\" && o2.type === \"remove_text\") {\r\n                relationship = 0; // Delete only once\r\n            } else if (o1.type === \"insert_text\" && o2.type === \"remove_text\") {\r\n                relationship = -1;\r\n                effectsRelation.set(o1Key, o2Key);\r\n            }\r\n        }\r\n        return relationship;\r\n    }\r\n\r\n    function exclusionTransform(o2: CustomOperation, o1: CustomOperation) {\r\n        let relationship: number = get_ER_ET(o1, o2);\r\n        let newOp2: CustomOperation = copy(o2);\r\n        if (relationship === 0) {\r\n            newOp2.offset = -1;\r\n            // throw new Exception(\"HALT, DOUBLE DELETION\");\r\n        } else {\r\n            newOp2 = copy(o2);\r\n\r\n            if (relationship < -1) {// o1 precedes o2 so transform o2\r\n                if (o1.type === \"insert_text\") {\r\n                    newOp2.offset--; // Shift index to the left by 1\r\n                } else { // o1.type = deletion\r\n                    newOp2.offset++;// Shift index to the right by 1\r\n                }\r\n            }\r\n        }\r\n        return newOp2;\r\n    }\r\n\r\n    function get_ER_ET(o1: CustomOperation, o2: CustomOperation) {\r\n        let o1Key = { siteID: o1.siteID as number, stateID: o1.stateID as number };\r\n        let o2Key = { siteID: o2.siteID as number, stateID: o2.stateID as number };\r\n        if (effectsRelation.get(o1Key) === o2Key) {\r\n            return -1;\r\n        }\r\n        if (effectsRelation.get(o2Key) === o1Key) {\r\n            return 1;\r\n        }\r\n\r\n        let relationship: number;\r\n\r\n        if (o1.offset < o2.offset) {\r\n            relationship = -1;\r\n        } else if (o1.offset > o2.offset) {\r\n            relationship = 1;\r\n        } else { // o1.pos == o2.pos\r\n            if (o1.type === \"insert_text\" && o2.type === \"insert_text\") {\r\n                relationship = 1;\r\n            } else if (o1.type === \"remove_text\" && o2.type === \"remove_text\") {\r\n                relationship = -1;\r\n            } else if (o1.type === \"remove_text\" && o2.type === \"insert_text\") {\r\n                relationship = 1;\r\n            } else { // o1.type = ins, o2.type = del\r\n                relationship = 0;\r\n            }\r\n        }\r\n\r\n        // record in ER\r\n        switch (relationship) {\r\n            case -1:\r\n                effectsRelation.set(o1Key, o2Key);\r\n                break;\r\n            case 1:\r\n                effectsRelation.set(o2Key, o1Key);\r\n                break;\r\n        }\r\n\r\n        return relationship;\r\n    }\r\n\r\n    /*\r\n     * Precondition: Sequence must be IT-safe (i.e. all insertion operations should\r\n     * be before deletion operations\r\n     */\r\n    function it_sq(op: CustomOperation, sequence: CustomOperation[]) {\r\n        let newOp: CustomOperation = copy(op); // Copy the object\r\n        for (let i = 0; i < sequence.length; i++) {\r\n            newOp = inclusionTransform(newOp, sequence[i]);\r\n            if (newOp.offset < 0) { //identity operation\r\n                break;\r\n            }\r\n        }\r\n        return newOp;\r\n    }\r\n\r\n\r\n    /*\r\n     * Precondition: Sequence must be ET-safe (i.e. for any two i,j where i<j,\r\n     * either pos(i)<pos(j) or pos(i)=pos(j) but j deletes i's insertion\r\n     */\r\n    function et_sq(op: CustomOperation, sequence: CustomOperation[]) {\r\n        let newOp: CustomOperation = copy(op); // Copy the object\r\n        let i = 0;\r\n\r\n        // Since our array is sorted by Effects Relation, this first for-loop removes\r\n        // all characters\r\n        // which do not affect op because they are on the right of it. Possible\r\n        // optimisation by not calling ET?\r\n        // Double check in get_er_et?\r\n        for (i = sequence.length - 1; i >= 0; i--) {\r\n            newOp = exclusionTransform(newOp, sequence[i]);\r\n            if (get_ER_ET(sequence[i], newOp) === -1) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // The remaining elements from the last array do affect op\r\n        for (let j = i - 1; j >= 0; i--) {\r\n            if (sequence[j].type === \"insert_text\") {\r\n                newOp.offset--;\r\n            } else {\r\n                newOp.offset++;\r\n            }\r\n        }\r\n        return newOp;\r\n    }\r\n\r\n    function transpose(o2: CustomOperation, o1: CustomOperation) {\r\n        let transposedOperations: CustomOperation[] = [];\r\n\r\n        if (get_ER_ET(o1, o2) === 0) {// Same character, don't transpose, return as is\r\n            //arr.splice(index, 0, item);\r\n            transposedOperations.push(o1)\r\n            transposedOperations.push(o2);\r\n        } else {\r\n            transposedOperations.push(exclusionTransform(o1, o2));\r\n            transposedOperations.push(inclusionTransform(o2, transposedOperations[0]));\r\n        }\r\n\r\n        return transposedOperations;\r\n    }\r\n\r\n\r\n    function transposeOSq(sq: CustomOperation[], op: CustomOperation) {\r\n\r\n        let newOp = copy(op); // Clone op into newOp\r\n        let newSq: CustomOperation[] = [];\r\n\r\n        // Clone the sequence\r\n        sq.forEach(operation => {\r\n            newSq.push(copy(operation));\r\n        });\r\n\r\n        let transposedElements: CustomOperation[];\r\n        for (let i = sq.length - 1; i >= 0; i--) {\r\n            transposedElements = transpose(newSq[i], newOp);\r\n            newOp = transposedElements[0];\r\n            newSq[i] = transposedElements[1];\r\n            console.log(\"transposeOSq\");\r\n        }\r\n\r\n        let response = [newOp, newSq];\r\n        return response;\r\n    }\r\n\r\n    // Given an operation o and a sequence sq, returns the list of all operations\r\n    // that happened before o and the list of all that happened\r\n    // concurrently with o from sq. Currently looks at stateID, might have to\r\n    // revisit TODO\r\n    function transposePreCon(op: CustomOperation, sq: CustomOperation[]) {\r\n        let msg = \"\";\r\n        sq.forEach((el) => {\r\n            msg += el.stateID + \" | \"\r\n        })\r\n        console.log(msg)\r\n        let happened: CustomOperation[] = [];\r\n        let concurrent: CustomOperation[] = [];\r\n        let sequences = [];\r\n        for (let i = 0; i < sq.length; i++) {\r\n            if (sq[i].stateID >= op.stateID) {\r\n                concurrent.push(sq[i]);\r\n            } else {\r\n                let response = transposeOSq(concurrent, sq[i]);\r\n                happened.push(response[0]);\r\n            }\r\n        }\r\n        sequences.push(happened);\r\n        sequences.push(concurrent);\r\n        return sequences;\r\n    }\r\n\r\n\r\n    // Given a sequence sq of insertions and deletions, returns a list of insertions\r\n    // and a list of deletions.\r\n    // These lists are transposed so that the effects of the initial sequence sq and\r\n    // the effect of sqi+sqd is the same\r\n    // Currently looks at stateID, might have to revisit TODO\r\n    function transposeInsDel(sq: CustomOperation[]) {\r\n        let insertions: CustomOperation[] = [];\r\n        let deletions: CustomOperation[] = [];\r\n        let sequences: any = [];\r\n        for (let i = 0; i < sq.length; i++) {\r\n            if (sq[i].type === \"remove_text\") {\r\n                deletions.push(sq[i]);\r\n            } else {\r\n                let response = transposeOSq(deletions, sq[i]);\r\n                insertions.push(response[0]);\r\n            }\r\n        }\r\n        sequences.push(insertions);\r\n        sequences.push(deletions);\r\n        return sequences;\r\n    }\r\n\r\n    function buildETSOS(sq: CustomOperation[]) {\r\n        if (sq.length < 1) {\r\n            return sq;\r\n        }\r\n        let newSq: CustomOperation[] = [];\r\n        let op: CustomOperation;\r\n        let flag = true;\r\n\r\n        newSq.push(sq[0]);\r\n        for (let i = 1; i < sq.length; i++) {\r\n            op = copy(sq[i]);\r\n            flag = false;\r\n            for (let j = newSq.length - 1; j >= 0; j--) {\r\n                if (flag) {\r\n                    let o1Key = { siteID: newSq[j].siteID as number, stateID: newSq[j].stateID as number };\r\n                    let o2Key = { siteID: op.siteID as number, stateID: op.stateID as number };\r\n                    effectsRelation.set(o1Key, o2Key);\r\n                } else {\r\n                    if (get_ER_ET(newSq[j], op) === -1) { // if sq[j] is to the left of op\r\n\r\n                        // PLEASE TEST THIS\r\n                        let temp: CustomOperation[] = [];\r\n                        for (let k = 0; k <= j; k++) {\r\n                            temp.push(newSq[k]);\r\n                        }\r\n                        temp.push(op);\r\n                        for (let k = j + 1; k <= newSq.length - 1; k++) {\r\n                            temp.push(newSq[k]);\r\n                        }\r\n                        newSq = temp;\r\n\r\n                        flag = true;\r\n                    } else {\r\n                        let transposed: CustomOperation[] = transpose(newSq[j], op);\r\n                        op = transposed[0];\r\n                        newSq[j] = transposed[1];\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!flag) {\r\n                newSq.splice(0, 0, op);\r\n            }\r\n        }\r\n        return newSq;\r\n    }\r\n\r\n\r\n    function copy(operation: Operation) {\r\n        //Hacky solution to copy an object\r\n        return JSON.parse(JSON.stringify(operation));\r\n    }\r\n\r\n\r\n\r\n}",{"ruleId":"21","severity":1,"message":"22","line":216,"column":14,"nodeType":"23","messageId":"24","endLine":216,"endColumn":23},{"ruleId":"21","severity":1,"message":"25","line":479,"column":14,"nodeType":"23","messageId":"24","endLine":479,"endColumn":29},"@typescript-eslint/no-unused-vars","'integrate' is defined but never used.","Identifier","unusedVar","'transposePreCon' is defined but never used."]